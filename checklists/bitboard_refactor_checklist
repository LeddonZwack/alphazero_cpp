===========================
 Bitboard Refactor Checklist
===========================

Overview:
Tracks the status of each bitboard function in our C++ engine relative to the original Python code
and any performance concerns. Updated after intrinsics patch.

--------------------------------------------------------------------------------
‚úÖ = Done / Accurate Port   ‚ö†Ô∏è = Needs Refactor   üí° = Optional Optimization
--------------------------------------------------------------------------------

[BITBOARD CORE (Bitboard.hpp)]
---------------------------------
‚úÖ complement(...)       - Simple bitwise NOT (masked to 64 bits)
‚úÖ getLSB(...)           - Uses x & -x, matches Python
‚úÖ removeLSB(...)        - Works fine, same as Python
‚úÖ toString(...)         - Still string-based for debugging (fine for now)
‚úÖ reverse(...)          - [UPDATED] Now uses bitwise approach instead of string
‚úÖ popcount(...)         - [ADDED] Uses compiler intrinsics if available
‚úÖ lsb_index(...)        - [ADDED] throws error if b=0, uses intrinsics

[SLIDING PIECES (SlidingPieces.hpp)]
---------------------------------
‚úÖ Currently uses shift/mask scanning for rooks/bishops
‚ö†Ô∏è  If we want maximum performance: switch to magic bitboards
üí° This scanning is correct but slower than magic approach

[MAGIC BITBOARDS]
---------------------------------
‚ö†Ô∏è  Not yet implemented in C++ for rooks or bishops
üí° If we add them, we skip shift scanning in SlidingPieces and do table lookups

[PERFORMANCE STRATEGIES]
---------------------------------
‚úÖ Replaced string-based reversal with bitwise
‚úÖ Added intrinsics for popcount, ctz
‚ö†Ô∏è  Still scanning for rooks/bishops, no table-driven approach
‚ö†Ô∏è  No caching for is_in_check or repeated states yet

--------------------------------------------------------------------------------

Future Steps:
-----------
‚Ä¢ If needed, implement magic bitboard tables for rooks/bishops/queens
‚Ä¢ Possibly unify piece data in a single array for better cache usage
‚Ä¢ If using concurrency, plan for apply/undo or object pooling in MCTS
